from numpy.typing import NDArray, ArrayLike, DTypeLike
from typing import (
    overload,
    BinaryIO,
    Type,
    Any,
    SupportsAbs,
    Protocol,
    Callable,
)
from pathlib import Path
from numpy import fft as fft
from typing_extensions import Unpack
from mte.typevar import TT, T, T2, T_co, C, C2, F, F2, I, I2

int_ = int
bool_ = bool
float_ = float
str_ = str
ndarray = NDArray
matrix = NDArray
uint8 = int
object = Any

class _SupportsPositive(Protocol[T_co]):
    def __pos__(self) -> T_co: ...

class _SupportsNegative(Protocol[T_co]):
    def __neg__(self) -> T_co: ...

class _SupportsReal(Protocol[T_co]):
    @property
    def real(self) -> T_co: ...

class _SupportsImag(Protocol[T_co]):
    @property
    def imag(self) -> T_co: ...

@overload
def array(object: ArrayLike[DTypeLike]) -> NDArray[DTypeLike]: ...
@overload
def array(
    object: ArrayLike[complex | str], dtype: Type[DTypeLike]
) -> NDArray[DTypeLike]: ...

asarray = array
copy = array

def sum(
    a: ArrayLike[C], axis: int | tuple[int, ...] | None = ..., dtype: Type[C] = ...
) -> NDArray[C]: ...
def min(a: ArrayLike[C], axis: int | tuple[int, ...] | None = ...) -> NDArray[C]: ...
def max(a: ArrayLike[C], axis: int | tuple[int, ...] | None = ...) -> NDArray[C]: ...
@overload
def mean(
    a: ArrayLike[C], axis: int | tuple[int, ...] | None = ...
) -> NDArray[float | C]: ...
@overload
def mean(
    a: ArrayLike[complex], axis: int | tuple[int, ...] | None = ..., *, dtype: Type[C]
) -> NDArray[C]: ...
@overload
def mean(
    a: ArrayLike[complex], axis: int | tuple[int, ...] | None, dtype: Type[C]
) -> NDArray[C]: ...
def average(
    a: ArrayLike[C],
    axis: int | tuple[int, ...] | None = ...,
    weights: ArrayLike[float] = ...,
) -> NDArray[float | C]: ...
def var(a: ArrayLike[T], *, ddof: int = ...) -> float: ...
def ravel(a: ArrayLike[T]) -> NDArray[T]: ...
def save(file: str | Path | BinaryIO, arr: ArrayLike[Any]) -> None: ...
@overload
def zeros(shape: int | tuple[int, ...]) -> NDArray[float]: ...
@overload
def zeros(shape: int | tuple[int, ...], dtype: Type[T]) -> NDArray[T]: ...

ones = zeros

@overload
def arange(stop: T) -> NDArray[T]: ...
@overload
def arange(start: T, stop: T, step: T = ...) -> NDArray[T]: ...
def load(file: str | Path | BinaryIO) -> NDArray[Any]: ...
def all(a: ArrayLike[Any], axis: int | None = ...) -> NDArray[bool]: ...
def any(a: ArrayLike[Any]) -> NDArray[bool]: ...
def linspace(
    start: ArrayLike[T] | T,
    stop: ArrayLike[T] | T,
    num: int = ...,
    endpoint: bool = ...,
) -> NDArray[float]: ...
def exp(x: ArrayLike[C]) -> NDArray[C | float]: ...
def cumsum(a: ArrayLike[C]) -> NDArray[C]: ...
def array_equal(a1: Any, a2: Any, equal_Can: bool = ...) -> bool: ...
@overload
def empty(shape: int | tuple[int, ...]) -> NDArray[float]: ...
@overload
def empty(shape: int | tuple[int, ...], dtype: Type[T]) -> NDArray[T]: ...
def cos(x: ArrayLike[C], /) -> NDArray[C | float]: ...
def sin(x: ArrayLike[C], /) -> NDArray[C | float]: ...
def argwhere(a: ArrayLike[Any]) -> NDArray[int]: ...
def trapz(y: ArrayLike[C]) -> NDArray[float | C]: ...
def convolve(a: ArrayLike[C], v: ArrayLike[C2]) -> NDArray[C | C2]: ...
def where(condition: ArrayLike[bool]) -> NDArray[int]: ...
def log10(x: ArrayLike[C], /) -> NDArray[float | C]: ...
def zeros_like(a: ArrayLike[T]) -> NDArray[T]: ...
def sqrt(x: ArrayLike[C], /) -> NDArray[float | C]: ...
def percentile(a: ArrayLike[C], q: ArrayLike[F]) -> NDArray[float | C]: ...
def add(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2]: ...
def subtract(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2]: ...
def multiply(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2]: ...
def divide(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2 | float]: ...
def matmul(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2]: ...
def floor_divide(x1: ArrayLike[F], x2: ArrayLike[F2], /) -> NDArray[F | F2]: ...
def power(x1: ArrayLike[C], x2: ArrayLike[C2], /) -> NDArray[C | C2]: ...
def bitwise_xor(x1: ArrayLike[I], x2: ArrayLike[I2], /) -> NDArray[I | I2]: ...

bitwise_and = bitwise_xor
bitwise_or = bitwise_xor

def divmod(
    x1: ArrayLike[F], x2: ArrayLike[F2], /
) -> tuple[NDArray[F | F2], NDArray[F | F2]]: ...
def mod(x1: ArrayLike[F], x2: ArrayLike[F2], /) -> NDArray[F | F2]: ...
def less(x1: ArrayLike[complex], x2: ArrayLike[complex], /) -> NDArray[bool]: ...
def equal(x1: Any, x2: Any, /) -> NDArray[bool]: ...

not_equal = equal

less_equal = less
greater = less
greater_equal = less

def positive(x: ArrayLike[_SupportsPositive[T]], /) -> NDArray[T]: ...
def negative(x: ArrayLike[_SupportsNegative[T]], /) -> NDArray[T]: ...
def absolute(x: ArrayLike[SupportsAbs[C]], /) -> NDArray[C]: ...

abs = absolute

def invert(x: ArrayLike[I], /) -> NDArray[I]: ...
def shape(a: ArrayLike[Any]) -> tuple[int, ...]: ...
def size(a: ArrayLike[Any]) -> int: ...
def real(val: ArrayLike[_SupportsReal[T]]) -> NDArray[T]: ...
def imag(val: ArrayLike[_SupportsImag[T]]) -> NDArray[T]: ...

pi: float

newaxis = None

def apply_along_axis(
    func1d: Callable[[NDArray[T], Unpack[TT]], ArrayLike[T2]],
    axis: int,
    arr: NDArray[T],
    *args: Unpack[TT],
) -> NDArray[T2]: ...
def repeat(
    a: ArrayLike[T], repeats: ArrayLike[int], axis: int | None = ...
) -> NDArray[T]: ...
def rint(x: ArrayLike[float], /) -> NDArray[int]: ...
