from numpy.typing import NDArray, ArrayLike, DTypeLike
from typing import (
    TypeVar,
    overload,
    BinaryIO,
    Type,
    Any,
    SupportsAbs,
    Protocol,
    Callable,
)
from pathlib import Path
from numpy import fft as fft
from typing_extensions import TypeVarTuple, Unpack

_Tuple = TypeVarTuple("_Tuple")
_T = TypeVar("_T")
_T2 = TypeVar("_T2")
_T_cov = TypeVar("_T_cov", covariant=True)
_C = TypeVar("_C", bound=complex)
_C2 = TypeVar("_C2", bound=complex)
_F = TypeVar("_F", bound=float)
_F2 = TypeVar("_F2", bound=float)
_I = TypeVar("_I", bound=int)
_I2 = TypeVar("_I2", bound=int)

int_ = int
bool_ = bool
float_ = float
str_ = str
ndarray = NDArray
matrix = NDArray
uint8 = int
object = Any

class _SupportsPositive(Protocol[_T_cov]):
    def __pos__(self) -> _T_cov: ...

class _SupportsNegative(Protocol[_T_cov]):
    def __neg__(self) -> _T_cov: ...

class _SupportsReal(Protocol[_T_cov]):
    @property
    def real(self) -> _T_cov: ...

class _SupportsImag(Protocol[_T_cov]):
    @property
    def imag(self) -> _T_cov: ...

@overload
def array(object: ArrayLike[DTypeLike]) -> NDArray[DTypeLike]: ...
@overload
def array(
    object: ArrayLike[complex | str], dtype: Type[DTypeLike]
) -> NDArray[DTypeLike]: ...

asarray = array
copy = array

def sum(
    a: ArrayLike[_C], axis: int | tuple[int, ...] | None = ..., dtype: Type[_C] = ...
) -> NDArray[_C]: ...
def min(a: ArrayLike[_C], axis: int | tuple[int, ...] | None = ...) -> NDArray[_C]: ...
def max(a: ArrayLike[_C], axis: int | tuple[int, ...] | None = ...) -> NDArray[_C]: ...
@overload
def mean(
    a: ArrayLike[_C], axis: int | tuple[int, ...] | None = ...
) -> NDArray[float | _C]: ...
@overload
def mean(
    a: ArrayLike[complex], axis: int | tuple[int, ...] | None = ..., *, dtype: Type[_C]
) -> NDArray[_C]: ...
@overload
def mean(
    a: ArrayLike[complex], axis: int | tuple[int, ...] | None, dtype: Type[_C]
) -> NDArray[_C]: ...
def average(
    a: ArrayLike[_C],
    axis: int | tuple[int, ...] | None = ...,
    weights: ArrayLike[float] = ...,
) -> NDArray[float | _C]: ...
def var(a: ArrayLike[_T], *, ddof: int = ...) -> float: ...
def ravel(a: ArrayLike[_T]) -> NDArray[_T]: ...
def save(file: str | Path | BinaryIO, arr: ArrayLike[Any]) -> None: ...
@overload
def zeros(shape: int | tuple[int, ...]) -> NDArray[float]: ...
@overload
def zeros(shape: int | tuple[int, ...], dtype: Type[_T]) -> NDArray[_T]: ...

ones = zeros

@overload
def arange(stop: _T) -> NDArray[_T]: ...
@overload
def arange(start: _T, stop: _T, step: _T = ...) -> NDArray[_T]: ...
def load(file: str | Path | BinaryIO) -> NDArray[Any]: ...
def all(a: ArrayLike[Any], axis: int | None = ...) -> NDArray[bool]: ...
def any(a: ArrayLike[Any]) -> NDArray[bool]: ...
def linspace(
    start: ArrayLike[_T] | _T,
    stop: ArrayLike[_T] | _T,
    num: int = ...,
    endpoint: bool = ...,
) -> NDArray[float]: ...
def exp(x: ArrayLike[_C]) -> NDArray[_C | float]: ...
def cumsum(a: ArrayLike[_C]) -> NDArray[_C]: ...
def array_equal(a1: Any, a2: Any, equal_Can: bool = ...) -> bool: ...
@overload
def empty(shape: int | tuple[int, ...]) -> NDArray[float]: ...
@overload
def empty(shape: int | tuple[int, ...], dtype: Type[_T]) -> NDArray[_T]: ...
def cos(x: ArrayLike[_C], /) -> NDArray[_C | float]: ...
def sin(x: ArrayLike[_C], /) -> NDArray[_C | float]: ...
def argwhere(a: ArrayLike[Any]) -> NDArray[int]: ...
def trapz(y: ArrayLike[_C]) -> NDArray[float | _C]: ...
def convolve(a: ArrayLike[_C], v: ArrayLike[_C2]) -> NDArray[_C | _C2]: ...
def where(condition: ArrayLike[bool]) -> NDArray[int]: ...
def log10(x: ArrayLike[_C], /) -> NDArray[float | _C]: ...
def zeros_like(a: ArrayLike[_T]) -> NDArray[_T]: ...
def sqrt(x: ArrayLike[_C], /) -> NDArray[float | _C]: ...
def percentile(a: ArrayLike[_C], q: ArrayLike[_F]) -> NDArray[float | _C]: ...
def add(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2]: ...
def subtract(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2]: ...
def multiply(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2]: ...
def divide(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2 | float]: ...
def matmul(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2]: ...
def floor_divide(x1: ArrayLike[_F], x2: ArrayLike[_F2], /) -> NDArray[_F | _F2]: ...
def power(x1: ArrayLike[_C], x2: ArrayLike[_C2], /) -> NDArray[_C | _C2]: ...
def bitwise_xor(x1: ArrayLike[_I], x2: ArrayLike[_I2], /) -> NDArray[_I | _I2]: ...

bitwise_and = bitwise_xor
bitwise_or = bitwise_xor

def divmod(
    x1: ArrayLike[_F], x2: ArrayLike[_F2], /
) -> tuple[NDArray[_F | _F2], NDArray[_F | _F2]]: ...
def mod(x1: ArrayLike[_F], x2: ArrayLike[_F2], /) -> NDArray[_F | _F2]: ...
def less(x1: ArrayLike[complex], x2: ArrayLike[complex], /) -> NDArray[bool]: ...
def equal(x1: Any, x2: Any, /) -> NDArray[bool]: ...

not_equal = equal

less_equal = less
greater = less
greater_equal = less

def positive(x: ArrayLike[_SupportsPositive[_T]], /) -> NDArray[_T]: ...
def negative(x: ArrayLike[_SupportsNegative[_T]], /) -> NDArray[_T]: ...
def absolute(x: ArrayLike[SupportsAbs[_C]], /) -> NDArray[_C]: ...

abs = absolute

def invert(x: ArrayLike[_I], /) -> NDArray[_I]: ...
def shape(a: ArrayLike[Any]) -> tuple[int, ...]: ...
def size(a: ArrayLike[Any]) -> int: ...
def real(val: ArrayLike[_SupportsReal[_T]]) -> NDArray[_T]: ...
def imag(val: ArrayLike[_SupportsImag[_T]]) -> NDArray[_T]: ...

pi: float

newaxis = None

def apply_along_axis(
    func1d: Callable[[NDArray[_T], Unpack[_Tuple]], ArrayLike[_T2]],
    axis: int,
    arr: NDArray[_T],
    *args: Unpack[_Tuple],
) -> NDArray[_T2]: ...
def repeat(
    a: ArrayLike[_T], repeats: ArrayLike[int], axis: int | None = ...
) -> NDArray[_T]: ...
def rint(x: ArrayLike[float], /) -> NDArray[int]: ...
